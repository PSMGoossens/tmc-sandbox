#!/usr/bin/env ruby

PROJECT_ROOT = File.dirname(File.dirname(File.realpath(__FILE__)))
$LOAD_PATH.unshift "#{PROJECT_ROOT}/web/ext"
$LOAD_PATH.unshift "#{PROJECT_ROOT}/web/lib"

require 'rubygems'
require 'lockfile'
require 'yaml'
require 'fileutils'
require 'shellwords'

require 'shell_utils'

class SandboxManager

  class BaseConfig
    def initialize(port)
      @port = port.to_i
    end
    
    attr_reader :port
    
    def sandbox_files_path
      "#{PROJECT_ROOT}/output"
    end
    
    def master_copy_path
      "#{PROJECT_ROOT}/web"
    end
    
    # Will chown created sandboxes to this user
    def tmc_user
      'tmc'
    end
    
    def site_yml_contents
      # Don't define sandbox_files_root here, anything else goes.
      # This will replace any site.yml in the master copy.
      {}
    end
    
    # Hooks available: {before,after}_hook where hook may be
    # start, stop, create, destroy
  end
  
  # To be mixed in to BaseConfig if desired.
  # Configures port 30XX to have tapdev tmc_tapXX
  # and internal IP 192.168.1XX.
  module NetworkConfig
    def configure_interfaces?
      true
    end
    
    def start_stop_interfaces?
      true
    end
    
    def configure_squid?
      true
    end
    
    def configure_dnsmasq?
      true
    end
    
    def number
      if 3000 < @port && @port < 3100
        @port - 3000
      else
        raise "Default NetworkConfig only knows how to deal with ports 3001-3099."
      end
    end
    
    def tapdev
      "tap_tmc#{number}"
    end
    
    def internal_ip
      "192.168.#{number}.1"
    end
    
    def enable_maven_cache?
      false
    end
    
    def maven_tapdev
      'tap_mvncache'
    end
    
    def maven_ip
      '192.168.210.1'
    end
    
    def manage_tap_devs_script
      "#{File.dirname(File.realpath(__FILE__))}/manage-tap-devs"
    end
    
    def site_yml_contents
      result = super
      result = result.merge({
        'extra_uml_args' => "eth0=tuntap,#{tapdev},,#{internal_ip}"
      })
      if enable_maven_cache?
        result = result.merge({
          'plugins' => {
            'maven_cache' => {
              'enabled' => true,
              'img1' => "#{master_copy_path}/cache/maven/1.img",
              'img2' => "#{master_copy_path}/cache/maven/2.img",
              'symlink' => "#{master_copy_path}/cache/maven/current.img",
              'work_dir' => "#{master_copy_path}/cache/maven/work",
              'tap_device' => maven_tapdev,
              'tap_ip' => maven_ip
            }
          }
        })
      end
      result
    end
    
    def before_create
      if configure_interfaces?
        create_tapdev(tapdev, internal_ip, tmc_user)
        if enable_maven_cache?
          create_tapdev(maven_tapdev, maven_ip, tmc_user)
        end
      end
    end
    
    def before_destroy
      check_root! if configure_interfaces?
    end
    
    def after_destroy
      if configure_interfaces?
        destroy_tapdev(tapdev, internal_ip)
        # don't destroy maven device since we're not sure if we're its last users
      end
    end
    
    def before_start
      if start_stop_interfaces?
        bring_tapdev_up(tapdev)
        if enable_maven_cache?
          bring_tapdev_up(maven_tapdev)
        end
      end
    end
    
    def before_stop
      if start_stop_interfaces?
        bring_tapdev_down(tapdev)
        # we won't bring the maven device down since others may use it
      end
    end
    
    
  private
    def create_tapdev(dev, ip, user)
      check_root!
      cmd = [
        manage_tap_devs_script,
        'add',
        dev,
        ip,
        user
      ]
      cmd << '--squid' if configure_squid?
      cmd << '--dnsmasq' if configure_dnsmasq?
      ShellUtils.sh!(cmd)
    end
    
    def destroy_tapdev(dev, ip)
      check_root!
      cmd = [
        manage_tap_devs_script,
        'del',
        dev,
        ip
      ]
      cmd << '--squid' if configure_squid?
      cmd << '--dnsmasq' if configure_dnsmasq?
      ShellUtils.sh!(cmd)
      
      reload_squid_config if configure_squid?
      reload_dnsmasq_config if configure_dnsmasq?
    end
    
    def bring_tapdev_up(dev)
      ShellUtils.sh!([manage_tap_devs_script, 'up', dev])
    end
    
    def bring_tapdev_down(dev)
      ShellUtils.sh!([manage_tap_devs_script, 'down', dev])
    end
    
    def check_root!
      if Process.uid != 0
        raise "Need to be root to configure network devices"
      end
    end
    
    def reload_squid_config
      ShellUtils.sh!(['/etc/init.d/squid3', 'reload'])
    end
    def reload_dnsmasq_config
      ShellUtils.sh!(['/etc/init.d/dnsmasq', 'restart'])
    end
  end
  
  
  class Instance
    def initialize(config)
      @config = config
    end
    
    attr_reader :config
    
    def port
      @config.port.to_s
    end
    
    def dir
      port
    end
    
    def pidfile
      dir + '/webrick.pid'
    end
    
    def create
      raise "#{dir} already exists!" if File.exist?(dir)
      FileUtils.cp_r(config.master_copy_path, dir)
      
      call_hook :before_create
      
      site_yml = @config.site_yml_contents
      site_yml.merge!({ 'sandbox_files_root' => File.expand_path(@config.sandbox_files_path) })
      File.open("#{dir}/site.yml", 'wb') {|f| f.write(YAML.dump(site_yml)) }
      
      ShellUtils.sh!(['chown', '-R', @config.tmc_user, dir])
      
      call_hook :after_create
    end
    
    def destroy
      stop if running?
      call_hook :before_destroy
      FileUtils.rm_rf(dir)
      call_hook :after_destroy
    end
    
    def rebuild
      stop
      destroy
      create
      start
    end
    
    def start
      call_hook :before_start
      
      cmd = "bundle exec rackup --server webrick --port #{port} --pid webrick.pid"
      if Process.uid == 0
        raise "Starting the webapp as root is a bad idea. Refusing to do it." if @config.tmc_user == 'root'
      end
      cmd = "#{cmd} >> webrick.log 2>&1 &"
      Dir.chdir(dir) do
        pid = Process.fork do
          Process::Sys.setreuid(tmc_user_uid, tmc_user_uid)
          Process.exec(cmd)
        end
        Process.waitpid(pid)
        raise "Failed to start instance #{port}. Status: #{$?}" if !$?.success?
      end
      
      if !wait_with_timeout(5) { running? }
        puts "Instance #{port} did not start for some reason."
        if File.exist?("#{dir}/webrick.log")
          log = File.read("#{dir}/webrick.log")
          puts "Here's the log:\n#{log}"
        else
          puts "No webrick.log was produced."
        end
        
        raise "Failed to start instance #{port}"
      end
      
      call_hook :after_start
    end
    
    def start!
      FileUtils.rm_f("#{dir}/webrick.pid")
      start
    end
    
    def stop
      call_hook :before_stop
      if running?
        pid = File.read(pidfile).to_i
        Process.kill('INT', pid)
        if !wait_with_timeout(5) { !running? }
          puts "Forcibly terminating instance #{port} PID #{pid} since it didn't respond to SIGINT."
          Process.kill('KILL', pid)
        end
      end
      call_hook :after_stop
    end
    
    def restart
      stop
      start
    end
    
    def running?
      File.exist?(pidfile) && pid_exists?(File.read(pidfile).to_i)
    end
    
  private
    def pid_exists?(pid)
      begin
        Process.kill(0, pid)
        true
      rescue
        false
      end
    end
    
    def wait_with_timeout(timeout, &block)
      start_time = Time.now
      while !block.call && Time.now - start_time < timeout
        sleep 0.2
      end
      block.call
    end
    
    def call_hook(hook)
      @config.send(hook) if @config.respond_to?(hook)
    end
    
    def tmc_user_uid
      Etc.getpwnam(@config.tmc_user).uid
    end
  end
  
  
  
  def initialize(args)
    parse_args(args)
  end
  
  
  def execute
    Lockfile.new("#{Dir.pwd}/manage-sandboxes.lock") do
      simple_commands = ['create', 'rebuild', 'destroy', 'start', 'start!', 'stop', 'restart']
      
      if @command == 'onboot'
        @command = 'start!'
        ports = all_ports
      else
        ports = optionally_args_as_ports
      end
      
      if simple_commands.include?(@command)
        instances = ports.map {|port| Instance.new(load_config(port)) }
        instances.each do |instance|
          puts "#{@command} #{instance.port}"
          instance.send(@command)
        end
      else
        raise "Unknown command: #{@command}"
      end
    end
  end
  
  def all_ports
    Dir.new('.').to_a.select {|d| d =~ /^\d+$/ }.sort
  end
  
private
  def optionally_args_as_ports
    if !@args.empty?
      @args.each(&:to_i)
    else
      all_ports
    end
  end

  def parse_args(args)
    @args = []
    args = args.clone
    until args.empty?
      arg = args.shift
      if arg == '-c' || arg == '--config'
        @config_file = args.shift
        args.unshift nil
      elsif arg == '-h' || arg == '--help'
        puts help_text
        exit(0)
      elsif !@command
        @command = arg
      else
        @args << arg
      end
    end
    
    if !@command
      puts help_text
      exit(1)
    end
  end
  
  def load_config(port)
    if !@config_file && File.exist?('config.rb')
      @config_file = 'config.rb'
    end
    if @config_file
      require @config_file
      SandboxManagerConfig.new(port)
    else
      BaseConfig.new(port)
    end
  end

  def help_text
    <<EOS
Usage: manage-sandboxes [-c|--config file] <command> [args]

Manages sandbox instances in the current directory.
A configuration file may be present. See config.example.rb.

If a network configuration is used, this script should be run as root.
Otherwise it may be run as the TMC user (default 'tmc').

Commands:
  create [ports]     - For each <port>, creates a new server listening to it
                       in a directory named <port>. The directory
                       will be a copy of 'tmc-sandbox/web'.
  
  rebuild [ports]    - Stops, deletes, creates and starts all or
                       the specified servers.
                       Useful to pull upgrades from the master copy.
  
  destroy [ports]    - Stops and deletes the given servers.
  
  start [ports]      - Starts the specified servers,
                       unless already started.
  
  stop [ports]       - Stops the specified servers.
  
  restart [ports]    - Restarts the specified servers.
  
  onboot             - Deletes all pidfiles and starts all instances.
                       Only invoke this if you're sure no instance is
                       already running.

EOS
  end
end

SandboxManager.new(ARGV).execute

