#!/usr/bin/env ruby
require 'shellwords'
require 'fileutils'

USAGE_TEXT = <<EOS
This script manages tap device entries for
/etc/network/interfaces on Debian-based systems.
It must be run as root.

It understands auto and iface stanzas and requires
that options of an iface stanza are indented
and immediately below the iface line without
empty lines in between.

The parts of the file that the script doesn't modify
are preserved.

Use --dnsmasq to also add/remove interface= and no-dhcp-interface= lines in
/etc/dnsmasq.conf.

Use --squid to also add/remove http_port <ipaddress>:3128 lines in
/etc/squid3/squid.conf.


Usage:

  manage-tap-devs add <tapN> <internal-ip> <tmc-user>
    Adds a tap device to /etc/network/interfaces unless it's already there.
  
  manage-tap-devs del <tapN> <internal-ip>
    Removes a tap device from /etc/network/interfaces if it's there.
  
  manage-tap-devs up <tapN>
    Brings a configured tap device up.

  manage-tap-devs down <tapN>
    Brings a configured tap device down.
  
Options:
  -p, --pretend      Don't really write conf files.
                     Show diff of what would be done.
  -h, --help         This.
  
  --dnsmasq          Also configure [add/del] dnsmasq but don't restart it.
  --squid            Also configure [add/del] squid but don't restart it.

EOS


module LineBasedFile
  # Includer must have DEFAULT_FILE constant

  def self.included(target)
    target.class_eval do
      def initialize(path, data)
        @path = path
        data = data.gsub("\r", "") # Just in case
        @lines = data.split("\n")
        @lines << "" if @lines.empty? # so .first and .last always work
      end
      
      attr_reader :path
      
      def data
        @lines.join("\n")
      end
      
      def self.load(path = self::DEFAULT_FILE)
        self.new(path, File.read(path))
      end
      
      def save
        File.open(path, 'wb') {|f| f.write(data) }
      end
      
      def backup
        FileUtils.cp(path, path + '.bak')
      end
    end
  end
end


class InterfacesFile
  DEFAULT_FILE = '/etc/network/interfaces'
  include LineBasedFile
  
  def iface_exists?(iface, ipaddr)
    !!find_iface_lines(iface)
  end
  
  def add_tap_iface(iface, ipaddr, tapuser)
    @lines << "" if !@lines.last.strip.empty?
    @lines << "auto #{iface}"
    @lines << "iface #{iface} inet static"
    @lines << "\taddress #{ipaddr}"
    @lines << "\tnetmask 255.255.255.0"
    @lines << "\tpre-up ip tuntap add dev #{iface} mode tap user #{tapuser}"
    @lines << "\tpost-down ip tuntap del dev #{iface} mode tap"
    @lines << ""
  end
  
  def remove_iface(iface, ipaddr)
    iface_lines = find_iface_lines(iface)
    @lines.slice!(iface_lines) if iface_lines != nil
    
    @lines.map! do |line|
      if line =~ /^\s*auto\s(.*)(#.*)?$/
        ifaces = $1.strip.split(/\s+/)
        if ifaces.include?(iface)
          ifaces.delete(iface)
          if !ifaces.empty?
            comment = if $2 then " #{$2}" else "" end
            "auto #{ifaces.join(' ')}#{comment}"
          else
            nil
          end
        else
          line
        end
      else
        line
      end
    end.reject!(&:nil?)

    @lines << "" if @lines.empty?
    @lines << "" if !@lines.last.strip.empty?
  end

private
  def find_iface_lines(iface)
    first = @lines.find_index {|line| line =~ /^\s*iface\s+#{iface}/ }
    if first != nil
      last = first
      while !(without_comment(@lines[last+1].to_s).strip.empty? || stanza_line?(@lines[last+1].to_s))
        last += 1
      end
      last += 1 if @lines[last+1].to_s.strip.empty?
      (first..last)
    else
      nil
    end
  end
  
  def without_comment(line)
    line.gsub(/#.*/, "")
  end
  
  def stanza_line?(line)
    !!(line =~ /^\s*(iface|mapping|auto|allow-|source)/)
  end
end


class DnsmasqFile
  DEFAULT_FILE = '/etc/dnsmasq.conf'
  include LineBasedFile
  
  def iface_exists?(iface, ipaddr)
    @lines.any? {|line| line =~ iface_regex_for(iface) }
  end
  
  def add_tap_iface(iface, ipaddr, tmc_user)
    iface_regex = iface_regex_for(iface)
    nodhcp_regex = nodhcp_regex_for(iface)
    
    if !@lines.any? {|line| line =~ iface_regex }
      @lines << "interface=#{iface}"
    end
    if !@lines.any? {|line| line =~ nodhcp_regex }
      @lines << "no-dhcp-interface=#{iface}"
    end
    
    @lines << "" if !@lines.last.strip.empty?
  end
  
  def remove_iface(iface, ipaddr)
    iface_regex = iface_regex_for(iface)
    nodhcp_regex = nodhcp_regex_for(iface)
    
    @lines.map! do |line|
      if line =~ iface_regex || line =~ nodhcp_regex
        nil
      else
        line
      end
    end.reject!(&:nil?)
    
    @lines << "" if !@lines.last.strip.empty?
  end
  
private
  def iface_regex_for(iface)
    /^\s*interface\s*=\s*#{iface}/
  end
  
  def nodhcp_regex_for(iface)
    /^\s*no-dhcp-interface\s*=\s*#{iface}/
  end
end


class SquidFile
  DEFAULT_FILE = '/etc/squid3/squid.conf'
  include LineBasedFile
  
  def port
    3128
  end
  
  def iface_exists?(iface, ipaddr)
    regex = http_port_regex_for(ipaddr)
    @lines.any? {|line| line =~ regex }
  end
  
  def add_tap_iface(iface, ipaddr, tmc_user)
    if !iface_exists?(iface, ipaddr)
      @lines << "http_port #{ipaddr}:#{port}"
    end
    
    @lines << "" if !@lines.last.strip.empty?
  end
  
  def remove_iface(iface, ipaddr)
    regex = http_port_regex_for(ipaddr)
    @lines.map! do |line|
      if line =~ regex
        nil
      else
        line
      end
    end.reject!(&:nil?)
    
    @lines << "" if !@lines.last.strip.empty?
  end
  
private
  def http_port_regex_for(ipaddr)
    /^\s*http_port\s*#{ipaddr}:#{port}/
  end
end


class TapDevManager
  def initialize(options = {})
    @options = {
      :pretend => false,
      :dnsmasq => false,
      :squid => false
    }.merge(options)
    @interfaces_file = InterfacesFile.load
    @dnsmasq_file = DnsmasqFile.load if @options[:dnsmasq]
    @squid_file = SquidFile.load if @options[:squid]
  end
  
  def pretend?
    @options[:pretend]
  end
  
  def add(tapdev, ipaddr, tmc_user)
    for file in files
      if !file.iface_exists?(tapdev, ipaddr)
        puts "Adding #{tapdev} #{ipaddr} to #{file.path}"
        file.add_tap_iface(tapdev, ipaddr, tmc_user)
        maybe_save(file)
      else
        puts "#{tapdev} #{ipaddr} already configured in #{file.path}"
      end
    end
  end
  
  def del(tapdev, ipaddr)
    for file in files
      file.remove_iface(tapdev, ipaddr)
      maybe_save(file)
    end
  end
  
  def up(tapdev)
    ifupdown('ifup', tapdev)
  end
  
  def down(tapdev)
    ifupdown('ifdown', tapdev)
  end
  
private
  def files
    [@interfaces_file, @dnsmasq_file, @squid_file].reject(&:nil?)
  end

  def maybe_save(file)
    if !pretend?
      file.backup
      file.save
    else
      puts
      puts "Would modify #{file.path} as follows if no --pretend was given:"
      puts "==="
      IO.popen(Shellwords.join(['diff', '-u', file.path, '-']), "w") do |pipe|
        pipe.write(file.data)
      end
      puts
    end
  end
  
  def ifupdown(which, tapdev)
    cmd = []
    cmd << which
    cmd << '-v'
    cmd << '--no-act' if pretend?
    cmd << tapdev
    system(Shellwords.join(cmd))
  end
end



def require_arg
  if ARGV.empty?
    puts USAGE_TEXT
    exit!(1)
  end
  ARGV.shift
end

def consume_opt(opt)
  !!ARGV.delete(opt)
end

if consume_opt('-h') || consume_opt('--help')
  puts USAGE_TEXT
  exit!(0)
end

options = {
  :pretend => consume_opt('-p') || consume_opt('--pretend'),
  :dnsmasq => consume_opt('--dnsmasq'),
  :squid => consume_opt('--squid')
}

if Process.uid != 0 && !pretend
  puts "This must be run as root."
  exit!(1)
end

man = TapDevManager.new(options)

command = require_arg
case command
when 'add'
  tapdev = require_arg
  ipaddr = require_arg
  tmc_user = require_arg
  man.add(tapdev, ipaddr, tmc_user)
when 'del'
  tapdev = require_arg
  ipaddr = require_arg
  man.del(tapdev, ipaddr)
when 'up'
  tapdev = require_arg
  man.up(tapdev)
when 'down'
  tapdev = require_arg
  man.down(tapdev)
else
  raise "Unknown command: #{command}"
end

